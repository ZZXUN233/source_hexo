---
layout: post
title: GEB-WU形式系统
author: zzxun
date: 2018-07-07 15:50:58
categories:
- 阅读
tags:
- 形式系统
- GEB中的小问题
- WJU 形式系统
---

** 这是一个在阅读GEB中发现的问题，并不是特别难，只是书开头的一道开胃菜吧！ **

##  问题提出
> 书的第一章 WU谜题中，作者提出了一种WJU形式系统，什么是形式系统，这里可以直接理解为公式的推导中用到的整个公式构建的体系（包括定理和公理）就是一个形式系统。
> 这个WU形式系统包括以下规则：（系统开始会给你一个由“W”，“J”，“U”三个字母中的一个或多个组成的字符串，比如：WUJ，WUU，WU……）
>> 1. 如果你的字符串以** J ** 结尾，哪么你可以在字符串最后加上一个** U **
>> 2. 如果你的字符串为** Wx ** 的形式（x代表WUJ的任意组合任意个数，也就是子字符串），哪么你可以得到 ** Wxx **形式的字符串（比如：WU ——> WUU ——> WUUUU）
>> 3. 如果你的字符串中出现 ** JJJ ** 哪么你可以用 ** U ** 来替换 ** JJJ ** （WUJJJ ——> WUU）
>> 4. 如果出现 ** UU ** ,哪么你可以直接去除这两个连续的** U **(WUUJ ——> WJ) 
> ### 最后抛出WU谜题：你现在拥有的字符串为：** WJ **，能否根据上面给出的规则推导得出** WU **
<!--more-->
## 问题引申
> 思考这个问题通常总是从一些尝试开始，比如简单做一些推导，比如书中给了一个题目是先试着从WJ推导出WUJJU：
> WJ——>WJJ——>WJJJJ——>WJJJJU——>WUJU——>WUJUUJU——>WUJJU，可以得出能从WJ推出WUJJU，（在形式系统的推导中有些编译原理根据所给语法构建特定句式的感觉）
> 哪么怎么从WJ推导出WU呢？
> 问出这个问题之前，作为人，常常会想按照给出的规则，WJ能否推出WU，要是能的话我在去推推看O_O（这就是作者提到的一个人和电脑的重要区别，人看待问题时通常有能够跳出“系统”的能力），而机器要实现这一点很难，至少说程序员要想写出这样面面俱到的代码，甚至在代码去解决一个问题前先判断了这个问题是否可以求解，这样显然是很难的，机器至今依旧只能按照人的意志行事，一切都是写死的，它们没有跳出系统的能力，这也是短时间内程序很难做出突破的地方。
## 问题求解
> 我做了一番尝试后，并没有从** WJ **推导出** WU **来，倒是我说服了自己这个是推导不出来的。我的证明很不严谨……
>>### 首先要从WJ到WU，那一定是按照规则进行n步后，消除了WJ中的J，不管消除其中的J后得到的什么，很可能是W＋（２ｎ+1）U这样的组合（n为自然数），但是没有J是必须的；
>>### 哪这个问题就又发生了转变，现在试着搞清楚怎么操作后能消除WJ中的那个J；
>>### 我们观察到规则（2）、（3）能改变J的个数，（2）能让J个数×2，（3）能让J个数-3；
>>### 于是这个问题又有了变化，变成了** 1 ** 经过一系列有顺序的（×2）、（-3）操作后能否变成** 0 **
-----
注意：在这里问题并没有变成 1x2^(n)-3m=0，求自然数n和m(因为每个字母都是完整的，没有负数个字母，没有小数个字母),而是像下图中描述的哪样生成数字：
{% asset_img WJU.png %}下面就是找产生的无穷的数中有没有3的倍数，如果有3n这个数，就可以通过n次-3操作来将J的个数变为0。

-----
这个时候计算机有能发挥其优势了，我发现每次在两个操作中选取一个进行，这就像是二叉树的生成过程，如果我们把所有的可执行操作都模拟一遍，看产生的数中有没有3的倍数。
于是有了这段程序：
~~~python
lis = [1]  # 记录开始我们有的J个数
lis1 = []   # 记录所有左边的生成数（*2后的数装在这里）
lis2 = []   # 记录右边的生成数（-3后得到的数在这里）

# 每调用一次这个方法就更新一次所有的数，当作下一次生成前的数的种类
def func():
    global lis, lis1, lis2
    for i in lis:
        lis1.append(i * 2)
        if i >= 3:
            lis2.append(i - 3)
    lis = lis1 + lis2
    lis1 = []
    lis2 = []
    lis = list(set(lis))


if __name__ == '__main__':
    for i in range(10):  # 模拟进行10层树的生成
        func()
    lis.sort()
    for i in lis:
        if i % 3 == 0:
            print("找到！")
            break
    print("没有找到3的倍数！")
    print(lis)
    print("产生数的个数为：%d个" % len(lis))
~~~
程序的最后脑残地遍历了一遍所有得到地数中，发现就目前可以很快求解的层数下，是找不到3的倍数的，也就是说在目前演练的范围内不能消WJ中除仅有的一个J，也就意味着WJ不能得到WU。
{% asset_img WU2.png %}
还可以看到在这个操作树的枚举中，去除重复的数和负数，数字的生成依然很快，到100个数时已经不知道我的电脑需要多久才能跑出来了，我找不到一种很好的数学方式可以直接证明在这两个操作下不能产生3的倍数的数，而且这种暴力枚举下，也没有做到不安全归纳法的方式来证明不能产生3的倍数。

** 最后具体做了件什么事呢？我大概就是试着告诉自己在进行很多次模拟下，都无法消除WJ中这个J，所以更别提WJ——>WU了。这里面的数学很难精确的提炼出来。这就是哪怕计算机都觉得困难的事（WJ怎么推出WU来）了。**


