---
layout: post
title: 字典序排序
author: zzxun
date: 2018-09-19 20:08:31
categories:
- 编程
tags:
- 算法
- 字典序排序
---

# 字典序排序的定义 #

查字典时，比如查单词 **Love** ，我们是从第一个字母L，开始查找，在A~Z开头中的单词中，不管是实际操作的二分查找还是别的方式查找，总能找到L打头的单词所在的位置范围，然后又在这个范围内开始查找O字母排第二的单词，之后又依次检索V字母，E字母，直到找到LOVE这个单词，紧跟着这个单词后面的单词是前面字母LOVE都相同的，长度比love长的单词比如lovely，知道没有这个单词了，才开始轮转下一个字母。

这个过程其实已经是在按照字典序排序的规则查找我们要的内容了，字典序的命名也是这样来的吧！我不管，我就是这么理解的。
<!--more-->

## 什么是全排列 ##

百度百科说：
>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。
>公式：全排列数f(n)=n!(定义0!=1)

没错，就是我们在概率论中学习的排列组合知识，还记得A排列，C组合这个吧！

$$ A^{n}_{n} = n! $$就是n的全排列。

## 字典序 ##

直接看下面的示例比较清晰：

# 字典序排序的小示例 #

abc三个字母的字典序排列：

|a|b|c|
|:-:|:-:|:-:|
|aa|ba|ca|
|aaa|baa|caa|
|aab|bab|cab|
|aac|bac|cac|
|ab|bb|cb|
|aba|bba|cba|
|abb|bbb|cbb|
|abc|bbc|cbc|
|ac|bc|cc|
|aca|bca|cca|
|acb|bcb|ccb|
|acc|bcc|ccc|

字典序的定义：

维基百科：
>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。
>通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序：下面用形式化的语言说明。

形式定义：
>给定两个偏序集A和B,(a,b)和(a′,b′)属于笛卡尔积 A × B，则字典序定义为 (a,b) ≤ (a′,b′) 当且仅当 a < a′ 或 (a = a′ 且 b ≤ b′). 结果是偏序。如果A和B是全序, 那么结果也是全序。

# 算法题目 #

{% asset_img psb.png %}

# 编程实现 #

算法的题目上一文中已经给出了！刚看这个题目的时候，竟然一时找不到这个排列的规律，我甚至以为ab这样的组合不存在于其中！

# 问题的核心 #

一下想到的求解方法：

+ 直接通过规律用数学算出来
+ 按照规则把这个字典序的全排列生成出来并字典排序好，再去检索这个字符串的位置(这是不好的方法)

# 计算 #

+ 每位都25种情况，位数为1~4位，全排列有多少种情况：
  
  $\sum_{i=1}^4 25^i {，4位全排列} $
+ 第一位特定字母打头（比如a）的有多少个
  $\sum_{i=1}^4 25^{i-1}  {，所有排列可以分成25个大组，每组就对应一种字母打头的} $

+ “baca”在什么位置？
  > b打头的排在所有的a打头的后面  $ 25^1+25^2+25^3=16275 $，b排在16275开始处，baca就需要知道aca对应的偏移，这个时候需要知道ba，baa，baaa，baa_*25，bab，bab_*25，bac，baca终于找到了：16275+1+1+3*1+2*25+1=16331
整理上面的规律过程，可以发现：
{% asset_img dict_sort.png %}

# 代码实现： #

+ 确定输入：例如cbcd、dba、这样的字符串
+ 输出：对应的index

~~~python
def getIndex(strInput):
    gLens = []
    for i in range(4):      # 计算25^3+25^2+25^1+25^0
        gLens.append(25 ** i)
    index = (ord(strInput[0]) - 97) * gLens.pop()   # 至少有一位编码，根据第一位分大组，此处不加1是因为不能为_._._._空
    if len(strInput) > 1:
        index += (ord(strInput[1]) - 97) * gLens.pop() + 1  # 开始算第一位（开始为0位），记得要加上 b
    if len(strInput) > 2:
        index += (ord(strInput[2]) - 97) * gLens.pop() + 1  # 开始算第二位（开始为0位），记得要加上 ba
    if len(strInput) > 3:
        index += (ord(strInput[3]) - 97) * gLens.pop() + 1  # 开始算第三位（开始为0位），记得要加上 baa
    return index

print(getIndex('baca'))
~~~


[原题的网址](https://www.nowcoder.com/questionTerminal/6fc8716ee33e4cc59d58d7e18712094e?orderByHotValue=1&questionTypes=000100&page=1&onlyReference=false)
