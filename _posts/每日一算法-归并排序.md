---
layout: post
title: 每日一算法--归并排序
author: zzxun
date: 2018-07-13 11:08:42
categories:
- 算法
tags:
- 归并排序
- 分治法
- 每日一算法
- 编程
- 插入排序
- 快速排序
---

## 计算思维 ##
这学期选了一个叫计算思维的个性课凑学分，学的时候才发现人家教的计算思维和我理解的计算思维完全是两个东西，老师讲的是云计算，大数据、分布式、物联网、人工智能……等很计算机乃至人们生活中火爆的名词解释，或是示例列举，还告诉同学们，生活在新时代，得学会用新时代特有的计算思维来决解问题……

我以为的计算思维其实大半都是数学思维，是求解问题的一种思维，放在计算机中，那就是算法设计。

维基中对计算思维的定义中讲到了 ** 3A ：** 
1. Abstraction: Problem formulation;
2. Automation: Solution expression;
3. Analyses: Solution execution and evaluation.
<!--more-->
-----
{% asset_img The_Computational_Thinking_Process.jpg %}
看这个图就能更好地理解一些了。。。

## 简单的排序 ##
给你一把打乱的牌，让你排序它们，你是怎么做的？
实际处理中，我们会有多种方式，下面我列举两种的详细步骤：
> 1. 左手为空，要排序的牌放在桌上牌面朝下，每次摸一张插入在左手牌中的正确位置（小于或是等于右边的牌），桌子上的牌取完后左手中的牌就是排序好的。
> 2. 所有的牌在左手中摊开，右手从小到大依次从左手摊开的牌中抽取牌，最后右手拿到的牌就是排序好的。
上面的两种常规做法已经和一些排序的算法思维很接近了，第一种方式可以明显地看出就是插入排序的原型，《算法导论》种对其进行了伪码描述，伪码上做了一些优化，如下：
## 插入排序的伪码 ##
~~~
for j=2 to A.length   
    key = A[j]
    i = j-1
    while i > 0 and A[i] > key
        A[i+1] = A[i] 
        i = i - 1
    A[i+1] = key
~~~
>
伪码的描述很像python的代码了，但是可以看到其中做了很多算法的处理，首先我们并没有新建一个数组来装排序后的牌（左手为空，逐个加入牌），而是为了节省计算机的运行空间，采取了用一个缓存位置key来表示当前摸起的牌，而A[1]就默认是最先摸起来的牌，A[2]~A[n]，每次摸起来的牌 A[i] 就同一级排好序 A[1]~A[i-1] (在这里没有按照数组从0开始计数，而是按照人们的常识从1开始计数)的牌依次做比较，比 A[m-1],A[m-2]……小的话就交换位置，并继续同前面排好序的牌做比较，直到到了牌首或是出现摸起来的牌比排好序的牌最右边的大，就开始摸下一张牌（令A[i+1]为key），重复这个操作，到最后一张牌被插入时，排序就完成了。
这就是伪代码这种形式化语言的好处，我用语言描述这个过程需要很多语言都不一定说得准确，通过表达式和条件控制的伪代码就能简洁明了的描述这个问题的求解步骤。
下面我试着简洁的将前面的第二种排序牌的操作进行伪码描述，其实这就是** 选择排序 **，每次从要未排序的数组中选择最小的牌与第一个元素交换位置，下一次就是从2~n个元素中选择最小的与第二个元素交换位置……
## 选择排序伪码及Python源码 ##
~~~
for i=1 to A.length-1   
    start = A[1]
    pos = 1
    for j=i to A.length
        if A[j] < start
            pos = j
            start = A[j]
    A[pos] = A[i]
    A[i] = start
~~~
注意在将伪码“兑换”为程序语言代码时有很多需要注意的点，最基本的就是数组或者列表的下标取值范围。上面的伪码换为python时如下：
~~~python
def C_sort(temp_list):
    for i in range(len(temp_list) - 1):
        start = temp_list[i]
        pos = i
        for j in range(i, len(temp_list)):
            if temp_list[j] < start:
                pos = j
                start = temp_list[j]
        temp_list[pos] = temp_list[i]
        temp_list[i] = start
~~~
因为还没有对函数编程有所了解，所以现在写的函数一直在追求** 传参数少 **这种个人的喜好在后面会遇到很多问题，到时候再提出来记录和说一下吧！算是挖了一个坑放在这里。
另外发现python适合那些马大哈式的程序员，图省事，不需要考虑变量的存储空间（不需要过多考虑），甚至变量的类型也由第一次赋值时决定，这些绝对是很省事的，但是写久了Python就会弱化自己写其它语言程序的能力。所以Python更像是编程中的一个简洁明了的框架，很多时候Python的一个功能调用语句，换到其它语言中就是一个需要自己实现的函数功能……所以造轮子的技术才是真技术，用别人的轮子迟早会陷入一种尴尬的局面的。
## 回到今天的主题——归并排序 ##
前面就这个排序探讨了一些问题还复习了两个简单的排序，现在开始学习今天的归并排序：
分治法几条核心思想：(我自己这么认为的，因为没写过几句和算法相关的代码)
>1. 分而治之，大的问题化小，小的问题用相同（似）的手段求解。
>2. 分治中一定有整合所有子问题解的步骤，也就是分——>合的过程。
>3. 分治法不一定能得到最优解。
### 归并两个有序数组 ###
问题：现在有两个排好序的数组A[q]和B[p]（排好序指的是默认从小到大排列），需要将两个数组合并为一个排好序的数组，实现流程（算法）如何进行？
语言描述：每次从两个数组的头取出较小的那个元素放在一个新数组C[q+p]中，直到其中一个数组取完所有元素后另一个数组的剩余元素就直接补在排序的数组C后面的空元素位置上，C就是合并后的数组。
伪代码描述：
~~~
MERGE(A,p,q,r)  #前面的数组A，B，C三个数组在这里都是A，A中排好序的部分为A[p...q],A[q+1...r],这样需要合并的元素总数为r-(q+1)+(q-p)=r-p+1个元素。规定p<=q<r
n1 = q-p+1  #前半段有序部分的长度，从p开始计数A[p],A[p+1],...A[q],..A[r]。A[p]到A[q]有q-p+1个元素
n2 = r-q    #后半段有序部分的长度，从q+1开始计数到r有r-(q+1)+1=r-q个元素
new L[1..n1+1],new R[1...n2+1] #创建两个分别有n1个和n2个元素的数组L和R
for i = 1 to n1
    L[i] = A[p+i-1]  #开始将A前面有序那段搬运到L上
for j = 1 to n2
    R[i] =A[q+j]    #开始将A后半段搬运到R上
L[n1+1] = ∞     #设置两个结束标志
R[n2+1] = ∞
i = 1
j = 1
for k = p to r          #此处到结尾都是在判断那边数组的开头元素小，就加入到排序的A中
    if L[i] <= R[j]
        A[k] = L[i]
        i = i+1
    else A[k] = R[j]
        j = j+1
~~~
到此处伪码相当于实现了一个函数，可以将一个数组A,这个数组A的[p~q]段和[q~r]段有序归并为A[p~r]段都有序的一个数组。
但是到这里还没有开始归并排序的正式操作，仅仅只是做出了准备工作，也看不到分治法的影子。但是做进一步思考可以发现，假设一个数组A只有两个元素，哪么执行MERGE(A,1,1,2)后就得到排序好的A,只有一个元素时就是排序好的，哪么A有三个以上的元素呢？比如n个元素，这时怎么操作？
+ n=3时，先MERGE(A,1,1,2),这时A[1~2]是排序好的，A[3]只有一个元素也相当于是排序好的，于是再执行MERGE(A,1,2,3)就可以得到排序好的A。（相信你也看到了分治法的影子了，子问题巧妙地被同样地方式化解了）
>+ n=2m时，可以先将A划分为A[1~m]和A[m+1~2m]
>+ n=2m+1时,可以划分A = A[1~m]+A[m+1~2m+1]
+ 上面两条可以写成一条:n=n时，A=[1~n//2]+A[n//2+1~n],//代表整除，去除余数部分。为什么一定是二分法来划分子问题呢？我想是因为1/2+1/4+1/8+1/16+……1/2^∞=1，方便完整地划分一个整问题
+ A[1~n//2]继续划分下去，总会得到A[1~3],A[4~6],或是单个元素两元素的一些子数组，三个元素一下的数组怎么利用MERGE排序在n=3时已经讨论过了，那么A[1~3]和A[4~6]是分别是排序好的后，MERGE(A,1,3,6)就可以排序6个，之后MERGE(A,1,6,12)就排序了12个元素，这样下去整个A就可以被排序了。。
### 归并排序的伪码实现 ###
~~~
MERGE_SORT(A,p,r)   #我们要排序的是A数组从p到q位置的元素。
if p < r
    q = [(p+r)/2]  #取整中位数作为第一次划分子数组的界线
    MERGE_SOERT(A,p,q)  #以相同方式求解前半个子问题
    MERGE_SORT(A,q+1,r)
    MERGE(A,p,q,r)      #思考在这种递归模式下，什么时候能运行到本句，也就是调用前面的伪码实现
~~~
上面的两段伪码合起来就是归并排序了！！！我只想说：不可小觑这些思想。
快速排序中也用到了分治和递归：伪码如下，可以对比帮助理解下归并排序：
### 快速排序的python代码实现 ###
~~~python
def QUICK_SORT(A):
    if len(A) < 2:
        return A
    elif len(A) == 2:
        if A[0]<A[1]:
            return A
        else:
            return [A[1],A[0]]
    else:
        mid = A[1]
        smaller = [i for i in A[1:] if i <= mid]
        bigger = [j for j in A[1:] if j > mid]
        return [QUICK_SORT(smaller) + mid +QUICK_SORT(bigger)]      #最后一句这递归调用实现了子问题的划分，return 加[]又整合了所有子问题的求解
~~~


